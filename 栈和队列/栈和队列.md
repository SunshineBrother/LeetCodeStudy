## 栈和队列

### 栈

栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。

**栈的特性：后进先出（Last In First Out），简写为LIFO**

![栈](https://github.com/SunshineBrother/LeetCodeStudy/blob/master/栈和队列/栈.png)

#### 栈的实现
我们主要实现栈的一下几个方法
- getSize：栈的大小
- isEmpty：栈是否为空
- push：压栈
- pop：出栈
- peek：栈顶
- toString：打印

```
class Stack: NSObject {
var stackArr = [Any]()

//栈的大小
func getSize() -> Int {
return stackArr.count
}
//栈是否为空
func isEmpty() -> Bool {
return stackArr.isEmpty
}
//压栈
func push(e:Any) {
stackArr.append(e)
}
//出栈
func pop() -> Any{
guard !stackArr.isEmpty else {
return (Any).self
}
let E = stackArr[stackArr.count - 1]
stackArr.removeLast()
return E
}
//栈顶
func peek() -> Any {
return stackArr[stackArr.count - 1]
}
//打印
func toString() ->String{
var res = "Stack: "
for (index,item) in stackArr.enumerated() {
if (index < stackArr.count - 1){
res.append("\(item),")
}
if (index == stackArr.count - 1){
res.append("\(item)")
}
}
return res
}


}

```


#### 栈的使用：有效的括号
给定一个只包括 `(`，`)`，`{`，`}`，`[`，`]` 的字符串，判断字符串是否有效。

有效字符串需满足：
- 1、左括号必须用相同类型的右括号闭合。
- 2、左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**
```
输入: "()"
输出: true
```
**示例 2:**
```
输入: "()[]{}"
输出: true
```
**示例 3:**
```
输入: "(]"
输出: false
```
**示例 4:**
```
输入: "([)]"
输出: false
```
**示例 5:**
```
输入: "{[]}"
输出: true
```


```
class Solution: NSObject {
let stack = Stack()
func isValid(_ s: String) -> Bool {
for c in s {
if (c == "(" || c == "[" || c == "{"){
stack.push(e: c)
}else{
//第一个如果不是上面的那三种情况直接return false
if stack.isEmpty() {
return false
}
//在出现第一个右括号的时候，一定有一个与之相对应的左括号，否则不符合规则；在出现第一个右括号，我们在栈中栈定元素，栈定元素应该是与右括号成对出现的，否则不符合规则
let topChar = stack.pop() as! Character
if (c == ")" && topChar != "("){
return false
}
if (c == "]" && topChar != "["){
return false
}
if (c == "}" && topChar != "{"){
return false
}
}

}
//在字符串遍历到最后，我们的栈应该是空的，因为左侧右侧成对出现便会被压出栈
return stack.isEmpty()
}
}

```

**代码解析**
上面这段逻辑代码我们就使用栈思想

- 1、首先第一个字符必须是`(`、`[`、`{`中的一个，否则必定不符合规则，这也就是下面这段代码
```
if (c == "(" || c == "[" || c == "{"){
stack.push(e: c)
}else{
//第一个如果不是上面的那三种情况直接return false
if stack.isEmpty() {
return false
}
}
```
- 2、在出现第一个右括号的时候，一定有一个与之相对应的左括号，否则不符合规则；在出现第一个右括号，我们在栈中栈定元素，栈定元素应该是与右括号成对出现的，否则不符合规则
```
let topChar = stack.pop() as! Character
if (c == ")" && topChar != "("){
return false
}
if (c == "]" && topChar != "["){
return false
}
if (c == "}" && topChar != "{"){
return false
}
```
- 3、在字符串遍历到最后，我们的栈应该是空的，因为左侧右侧成对出现便会被压出栈

我们在写过代码以后可以在[leetcode](https://leetcode-cn.com/explore/)中进行验证，这一道题是[leetcode](https://leetcode-cn.com/explore/)的第20题。


#### 队列

队列，一种限定性的线性表。它只允许在表一端进行插入，而在表的另一端进行删除操作。
队列是一种先进先出的数据结构
First In First Out(FIFO)

![队列](https://github.com/SunshineBrother/LeetCodeStudy/blob/master/栈和队列/队列.png)


**队列的简单实现**
```
class Queue: NSObject {
private var queueArr = [Any]()

//队列大小
func getSize() -> Int {
return queueArr.count
}
//添加队列
func enqueue(E:Any) {
queueArr.append(E)
}
//删除队列
//根据队列先进先出的原则，我们需要删除队列中的第一个元素。因为我们需要计算队列的复杂度，我们这里写2种删除队列的算法
//删除队列1：系统提供的remove第一个数组元素
func dequeue1() -> Any {
let res = queueArr[0]
queueArr.remove(at: 0)
return res
}
//打印
func toString() -> String {
var res = "Stack: "
for (index,item) in queueArr.enumerated() {
if (index < queueArr.count - 1){
res.append("\(item),")
}
if (index == queueArr.count - 1){
res.append("\(item)")
}
}

return res
}


}
```

对于添加队列，其实就是在队列的最后一位添加一个元素，算法复杂度为O(1)
但是删除队列，因为是删除的第一个元素其实就是走的一下这个算法，复杂度是O(n)
```
for index in 0..<queueArr.count-1 {
queueArr[index] = queueArr[index+1]
}
```


















